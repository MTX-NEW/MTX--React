---
description: 
globs: 
alwaysApply: false
---
FOLLOW ESTABLISHED PATTERNS: Use the existing pattern of Model → Route → Server/app.js → Frontend API calls → Page Hook → Page.
MATCH EXISTING SYNTAX: Follow the project's established coding conventions and naming patterns.
CODE TRACEABILITY: When fixing bugs, trace the issue through the entire stack (frontend to backend) before implementing changes.
SEQUELIZE CONSISTENCY: Use Sequelize as the ORM for all database interactions following existing model patterns.
ROUTE STRUCTURE: Create routes in the format shown in existing routes with proper error handling.
ERROR HANDLING: Always include ValidationError checks for Sequelize operations and consistent error response formatting.
API INTEGRATION: Always use the createApiService pattern for base CRUD operations.
CUSTOM ENDPOINTS: For specialized endpoints, extend the base API service using the established pattern.
STYLING APPROACH: Use Material UI for component-based styling and Bootstrap classes for inline styling , and main css file
STATE MANAGEMENT: Follow the existing state management patterns in the frontend code.
Development Process

ANALYZE FIRST: Thoroughly review relevant files before making any changes.
CODE MINIMALLY: Make the smallest possible change to achieve the desired outcome.
TEST THOROUGHLY: Consider edge cases and potential issues before finalizing code.
Provide clear explanations for all modifications.
ERROR TRACING: When fixing issues, include detailed explanation of the root cause.
API Development Rules

ENDPOINT CONSISTENCY: Match the RESTful pattern of the existing API endpoints.
RESPONSE FORMAT: Maintain consistent response formats for success and error states.
USE FACTORY PATTERN: Leverage the createApiService pattern for all new API services.
CUSTOM METHODS: Add custom methods to API services only when standard CRUD operations are insufficient.

// IMPORTANT : BUG OR ERROR FIXING DETECT THE BUG TYPE THEN TRACE IT IN REVERSE OF FEATURE CREATING SEQUENCE